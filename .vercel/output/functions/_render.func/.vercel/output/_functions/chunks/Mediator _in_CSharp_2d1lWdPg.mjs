const id = "Mediator _in_CSharp.md";
						const collection = "posts";
						const slug = "mediator-_in_csharp";
						const body = "\nFor a while think about a bustling marketplace, brimming with vendors hawking their wares. To get what you need, you have to weave through the throng, shouting your requests to each booth. It's loud, confusing, and frankly, not very efficient. Now picture this: a central plaza with a town crier. You simply tell the crier what you're looking for, and they relay it to everyone. Order emerges from chaos, and you leave with your prize much faster.\n\nThat's the magic of the Mediator pattern in software development. This is a behavioural design pattern that lowers dependency between programme components by having them communicate indirectly via a particular mediator object. Individual components can be easily modified, extended, and reused thanks to the Mediator, which eliminates their reliance on dozens of other classes.\n\nJust like the town crier, the mediator acts as a central hub for communication between objects. No longer do they need to shout directly at each other, creating a tangle of dependencies and complexity. Instead, they whisper their needs to the mediator, who then sorts it all out and ensures everyone gets what they need.\n\nThis makes code cleaner, more maintainable, and less prone to errors. If the rules of communication change, you only need to adjust the mediator, not every single connected object. It's like changing the town crier's script instead of rewriting all the vendor dialogues.\n\nHere's how the mediator works in a common example: a chat application. Imagine several users online, typing away furiously. Without a mediator, user A would need to know about user B, C, and everyone else to send messages. This tangled web of dependencies grows quickly as more users join, making the code brittle and hard to manage.\n\nEnter the chatroom mediator! Users talk to the mediator, who figures out who needs to hear what. If Alice sends a message, the mediator broadcasts it to everyone else in the room. No need for Alice to know or care about how many people are listening. The mediator handles the delivery, like a digital postman.\n\n### UML DESIGN\n\n![image](https://github.com/iamitprakash/astro-portfolio/assets/34869115/ce913b09-3ea4-4334-83db-b99f549867ef)\n\n```\ninterface IChatRoomMediator\n{\n  void Send(string message, Participant participant);\n}\n\nclass ChatRoomMediator : IChatRoomMediator\n{\n  private List<Participant> participants = new List<Participant>();\n\n  public void AddParticipant(Participant participant)\n  {\n      participants.Add(participant);\n  }\n\n  public void Send(string message, Participant sender)\n  {\n      foreach (Participant participant in participants)\n      {\n          if (participant != sender)\n          {\n              participant.Receive(message);\n          }\n      }\n  }\n}\n\nabstract class Participant\n{\n  protected IChatRoomMediator mediator;\n\n  public Participant(IChatRoomMediator mediator)\n  {\n      this.mediator = mediator;\n  }\n\n  public abstract void Send(string message);\n  public abstract void Receive(string message);\n}\n\nclass ConcreteParticipantA : Participant\n{\n  public ConcreteParticipantA(IChatRoomMediator mediator) : base(mediator)\n  {\n  }\n\n  public override void Send(string message)\n  {\n      Console.WriteLine($\"{this.GetType().Name}: Sending message: {message}\");\n      mediator.Send(message, this);\n  }\n\n  public override void Receive(string message)\n  {\n      Console.WriteLine($\"{this.GetType().Name}: Received message: {message}\");\n  }\n}\n\n// Similar implementation for ConcreteParticipantB\n```\n\n## Real World example (chat room use case)\n\nLet's implement a Mediator pattern facilitating loosely coupled communication between different Participants registering with a Chatroom. The Chatroom is the central hub through which all communication takes place. At this point only one-to-one communication is implemented in the Chatroom, but would be trivial to change to one-to-many.\n\n```\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mediator.RealWorld\n{\n    /// <summary>\n    /// Mediator Design Pattern\n    /// </summary>\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            // Create chatroom\n\n            Chatroom chatroom = new Chatroom();\n\n            // Create participants and register them\n\n            Participant George = new Beatle(\"George\");\n            Participant Paul = new Beatle(\"Paul\");\n            Participant Ringo = new Beatle(\"Ringo\");\n            Participant John = new Beatle(\"John\");\n            Participant Yoko = new NonBeatle(\"Yoko\");\n\n            chatroom.Register(George);\n            chatroom.Register(Paul);\n            chatroom.Register(Ringo);\n            chatroom.Register(John);\n            chatroom.Register(Yoko);\n\n            // Chatting participants\n\n            Yoko.Send(\"John\", \"Hi John!\");\n            Paul.Send(\"Ringo\", \"All you need is love\");\n            Ringo.Send(\"George\", \"My sweet Lord\");\n            Paul.Send(\"John\", \"Can't buy me love\");\n            John.Send(\"Yoko\", \"My sweet love\");\n\n            // Wait for user\n\n            Console.ReadKey();\n        }\n    }\n\n    /// <summary>\n    /// The 'Mediator' abstract class\n    /// </summary>\n\n    public abstract class AbstractChatroom\n    {\n        public abstract void Register(Participant participant);\n        public abstract void Send(\n            string from, string to, string message);\n    }\n\n    /// <summary>\n    /// The 'ConcreteMediator' class\n    /// </summary>\n\n    public class Chatroom : AbstractChatroom\n    {\n        private Dictionary<string, Participant> participants = new Dictionary<string, Participant>();\n\n        public override void Register(Participant participant)\n        {\n            if (!participants.ContainsValue(participant))\n            {\n                participants[participant.Name] = participant;\n            }\n\n            participant.Chatroom = this;\n        }\n\n        public override void Send(string from, string to, string message)\n        {\n            Participant participant = participants[to];\n\n            if (participant != null)\n            {\n                participant.Receive(from, message);\n            }\n        }\n    }\n\n    /// <summary>\n    /// The 'AbstractColleague' class\n    /// </summary>\n\n    public class Participant\n    {\n        Chatroom chatroom;\n        string name;\n\n        // Constructor\n\n        public Participant(string name)\n        {\n            this.name = name;\n        }\n\n        // Gets participant name\n\n        public string Name\n        {\n            get { return name; }\n        }\n\n        // Gets chatroom\n\n        public Chatroom Chatroom\n        {\n            set { chatroom = value; }\n            get { return chatroom; }\n        }\n\n        // Sends message to given participant\n\n        public void Send(string to, string message)\n        {\n            chatroom.Send(name, to, message);\n        }\n\n        // Receives message from given participant\n\n        public virtual void Receive(\n            string from, string message)\n        {\n            Console.WriteLine(\"{0} to {1}: '{2}'\",\n                from, Name, message);\n        }\n    }\n\n    /// <summary>\n    /// A 'ConcreteColleague' class\n    /// </summary>\n\n    public class Beatle : Participant\n    {\n        // Constructor\n\n        public Beatle(string name)\n            : base(name)\n        {\n        }\n\n        public override void Receive(string from, string message)\n        {\n            Console.Write(\"To a Beatle: \");\n            base.Receive(from, message);\n        }\n    }\n\n    /// <summary>\n    /// A 'ConcreteColleague' class\n    /// </summary>\n\n    public class NonBeatle : Participant\n    {\n        // Constructor\n        public NonBeatle(string name)\n            : base(name)\n        {\n        }\n\n        public override void Receive(string from, string message)\n        {\n            Console.Write(\"To a non-Beatle: \");\n            base.Receive(from, message);\n        }\n    }\n}\n```\n\n## Key takeaway:\n\nBenefits:\n\n1. **Reduced coupling**: Objects don't need to know about each other's internal details.\n2. **Enhanced maintainability**: Changes to interactions can be made in the mediator without affecting colleagues.\n3. **Centralized control**: Logic for complex interactions is consolidated in the mediator.\n4. \\*\\*Reusability: Colleagues can be reused independently in different contexts.\n\n## Common Use Cases:\n\n1. GUI components (buttons, menus, windows)\n2. Chat applications\n3. Game event systems\n4. Air traffic control systems\n5. Multi-threaded applications\n\n## Considerations:\n\n1. Mediator can become a central point of complexity.\n2. Overuse can lead to a God object anti-pattern.\n3. Use judiciously when benefits outweigh potential drawbacks.\n";
						const data = {title:"Mediator in C#",pubDate:"2024-01-13",description:"Mediator in C#",author:"Amit Prakash",image:{url:"https://media.licdn.com/dms/image/D5612AQGJM8WzCr7Fdg/article-cover_image-shrink_720_1280/0/1705136015310?e=1710979200&v=beta&t=ncMvOLNk0LjSh4sz-VPxBJwwzguQu_5v6DkmC3yqM6U",alt:"The full Astro logo."},tags:["astro","blogging","learning in public"]};
						const _internal = {
							type: 'content',
							filePath: "/Users/yashraj/Documents/pr/tejas-portfolio/src/content/posts/Mediator _in_CSharp.md",
							rawData: "\ntitle: \"Mediator in C#\"\npubDate: \"2024-01-13\"\ndescription: \"Mediator in C#\"\nauthor: \"Amit Prakash\"\nimage:\n  url: \"https://media.licdn.com/dms/image/D5612AQGJM8WzCr7Fdg/article-cover_image-shrink_720_1280/0/1705136015310?e=1710979200&v=beta&t=ncMvOLNk0LjSh4sz-VPxBJwwzguQu_5v6DkmC3yqM6U\"\n  alt: \"The full Astro logo.\"\ntags: [\"astro\", \"blogging\", \"learning in public\"]",
						};

export { _internal, body, collection, data, id, slug };
