import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_2Dcw_akG.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<p>LSM Tree: Write Like the Wind, Read with a Pause</p>\n<p>Imagine lightning-fast writes, like scribbling in a notepad. That’s an LSM tree. It prioritizes write speed by storing new data in temporary, in-memory structures. No slow disk writes slowing you down. But reading isn’t as immediate. Think back to flipping through that notepad – not exactly quick for finding specific notes. LSM trees need to periodically merge these notes into sorted files on disk, a process called compaction, to optimize for later reads.</p>\n<p>B+ Tree: The Orderly Librarian</p>\n<p>Think of a meticulously organized library with a helpful librarian (the B+ tree). Every book (data item) has its dedicated place, making searches a breeze. Need a specific title? The librarian guides you quickly through the alphabetized shelves. However, adding new books takes time – like carefully inserting them in the right order. Writes can be slower than with an LSM tree.</p>\n<p>So before jumping on conclusion let’s implement and see one by one.</p>\n<h2 id=\"lsm-tree-structure\">LSM Tree Structure:</h2>\n<p>Multiple levels of in-memory (MemTable) and disk-based (SSTables) components.</p>\n<p>New writes go to MemTable, optimized for fast writes.</p>\n<p>MemTable flushes to disk as SSTables when full.</p>\n<p>SSTables are immutable and sequentially written for fast reads.</p>\n<p>Periodic compaction merges sorted SSTables, removing duplicates and optimizing for reads.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>class LSMTree {</span></span>\n<span class=\"line\"><span>    private MemTable memTable;</span></span>\n<span class=\"line\"><span>    private List&#x3C;SSTable> levels; // Multiple levels of SSTables</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public void Insert(Key key, Value value) {</span></span>\n<span class=\"line\"><span>        memTable.Insert(key, value);</span></span>\n<span class=\"line\"><span>        if (memTable.IsFull()) {</span></span>\n<span class=\"line\"><span>            FlushMemTable();</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    private void FlushMemTable() {</span></span>\n<span class=\"line\"><span>        SSTable ssTable = memTable.CreateSSTable();</span></span>\n<span class=\"line\"><span>        levels.Add(ssTable);</span></span>\n<span class=\"line\"><span>        memTable = new MemTable(); // Create a new empty MemTable</span></span>\n<span class=\"line\"><span>        if (levels.Count > MaxLevels) {</span></span>\n<span class=\"line\"><span>            CompactLevels();</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    private void CompactLevels() {</span></span>\n<span class=\"line\"><span>        // Merge and sort SSTables from lower levels to higher levels, removing duplicates</span></span>\n<span class=\"line\"><span>        // This process optimizes read performance and controls disk usage</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public Value Get(Key key) {</span></span>\n<span class=\"line\"><span>        Value value = memTable.Get(key);</span></span>\n<span class=\"line\"><span>        if (value == null) {</span></span>\n<span class=\"line\"><span>            // Search through SSTables in levels, starting from the newest</span></span>\n<span class=\"line\"><span>            // Use a merge-sort strategy to combine results efficiently</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>        return value;</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<p>Key Considerations for Implementation:</p>\n<p>MemTable: Implement using a hash table or similar structure for fast writes.</p>\n<p>SSTables: Use B-trees or other efficient on-disk data structures for reads.</p>\n<p>Compaction: Choose a suitable compaction strategy (e.g., size-tiered, leveled) based on workload characteristics.</p>\n<p>Merge-Sort: Implement efficient merge-sort algorithms for key-value pairs during compaction and reads.</p>\n<h3 id=\"key-concepts-for-implementing-b--tree\">Key Concepts for Implementing B + tree.</h3>\n<p>A balanced tree with variable-sized nodes.</p>\n<p>Internal nodes store keys and pointers to child nodes.</p>\n<p>Leaf nodes store keys and associated values.</p>\n<p>All leaf nodes are at the same level, forming a linked list.</p>\n<p>Key Considerations for Implementation:</p>\n<p>MemTable: Implement using a hash table or similar structure for fast writes.</p>\n<p>SSTables: Use B-trees or other efficient on-disk data structures for reads.</p>\n<p>Compaction: Choose a suitable compaction strategy (e.g., size-tiered, leveled) based on workload characteristics.</p>\n<p>Merge-Sort: Implement efficient merge-sort algorithms for key-value pairs during compaction and reads.</p>\n<p>Key Operations:</p>\n<p>Insert, Search, Delete, Range queries, Maintaining balance through splitting and merging nodes.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>class BPlusTree {</span></span>\n<span class=\"line\"><span>    private Node root;</span></span>\n<span class=\"line\"><span>    private int order; // Maximum number of keys per node</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    // Node structure (can be further refined for internal and leaf nodes)</span></span>\n<span class=\"line\"><span>    private class Node {</span></span>\n<span class=\"line\"><span>        public List&#x3C;Key> Keys { get; set; }</span></span>\n<span class=\"line\"><span>        public List&#x3C;Node> Children { get; set; } // Only for internal nodes</span></span>\n<span class=\"line\"><span>        public List&#x3C;Value> Values { get; set; } // Only for leaf nodes</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    // Insert a key-value pair</span></span>\n<span class=\"line\"><span>    public void Insert(Key key, Value value) {</span></span>\n<span class=\"line\"><span>        Node leaf = FindLeafNode(key);</span></span>\n<span class=\"line\"><span>        InsertIntoLeaf(leaf, key, value);</span></span>\n<span class=\"line\"><span>        if (leaf.Keys.Count > order - 1) { // Split leaf if full</span></span>\n<span class=\"line\"><span>            SplitLeaf(leaf);</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    // Search for a key</span></span>\n<span class=\"line\"><span>    public Value Search(Key key) {</span></span>\n<span class=\"line\"><span>        Node leaf = FindLeafNode(key);</span></span>\n<span class=\"line\"><span>        int index = leaf.Keys.BinarySearch(key);</span></span>\n<span class=\"line\"><span>        if (index >= 0) {</span></span>\n<span class=\"line\"><span>            return leaf.Values[index];</span></span>\n<span class=\"line\"><span>        } else {</span></span>\n<span class=\"line\"><span>            return null; // Key not found</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    // Helper functions for node splitting, merging, etc.</span></span>\n<span class=\"line\"><span>    // ...</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<h3 id=\"key-implementation-considerations\">Key Implementation Considerations:</h3>\n<p><strong>Node Management</strong>: Implement internal and leaf nodes with appropriate properties.</p>\n<p><strong>Searching</strong>: Use efficient algorithms like binary search within nodes.</p>\n<p><strong>Insertion and Deletion</strong>: Handle node splitting and merging to maintain balance.</p>\n<p><strong>Range Queries</strong>: Leverage the linked leaf nodes for efficient traversal.</p>\n<p>so now for me it’s a draw, but with different prize categories. Here’s when each shines:</p>\n<h3 id=\"lsm-tree-wins\">LSM Tree Wins:</h3>\n<p>Write-heavy workloads: Think social media feeds or banking transactions. You need to store data fast, even if reading it sometimes requires a moment of patience.</p>\n<p>Scalability: As your data grows, LSM trees adapt gracefully. New “notepads” can be added seamlessly.</p>\n<p>Durability: Even if the system crashes, data in the in-memory structures and partially-compacted files is often recoverable.</p>\n<h3 id=\"b-tree-wins\">B+ Tree Wins:</h3>\n<p>Read-heavy workloads: Need lightning-fast searches? B+ trees are your allies. No merge delays, just straight to the data.</p>\n<p>Predictable performance: Writes might be slower, but they’re consistent. No surprises, just reliable performance.</p>\n<p>Efficiency: Once compacted, B+ trees offer space-efficient data storage. No duplicate scribbles in your library.</p>\n<p>Ultimately, the choice is yours. Consider your application’s priorities. Need nimble writes over instant reads? The LSM tree beckons. Crave quick searches and predictable performance? The B+ tree awaits. Choose your champion wisely, and your database will be a champion in its own right.</p>\n<p>Remember, there’s no one-size-fits-all solution. So, explore, experiment, and let the data structure duel guide you to the perfect fit for your database needs!</p>";

				const frontmatter = {"title":"The Duel of Data Structures: LSM Tree vs. B+ Tree","pubDate":"2024-01-26","description":"The Duel of Data Structures: LSM Tree vs. B+ Tree","author":"Amit Prakash","image":{"url":"https://media.licdn.com/dms/image/D5612AQEPIQlyu18qpQ/article-cover_image-shrink_720_1280/0/1706282956538?e=1711584000&v=beta&t=MzZdg1aqAoGOo4KrybWLYySuPRvT8ifMMeE346zVlg8","alt":"The full Astro logo."},"tags":["#PreflightParty","#hashtag#SecurityFirst","#hashtag#DataHarmony","#hashtag#NoMoreWebWalls"]};
				const file = "/Users/yashraj/Documents/pr/tejas-portfolio/src/content/posts/lsmvsbplustree.md";
				const url = undefined;
				function rawContent() {
					return "\nLSM Tree: Write Like the Wind, Read with a Pause\n\nImagine lightning-fast writes, like scribbling in a notepad. That's an LSM tree. It prioritizes write speed by storing new data in temporary, in-memory structures. No slow disk writes slowing you down. But reading isn't as immediate. Think back to flipping through that notepad – not exactly quick for finding specific notes. LSM trees need to periodically merge these notes into sorted files on disk, a process called compaction, to optimize for later reads.\n\nB+ Tree: The Orderly Librarian\n\nThink of a meticulously organized library with a helpful librarian (the B+ tree). Every book (data item) has its dedicated place, making searches a breeze. Need a specific title? The librarian guides you quickly through the alphabetized shelves. However, adding new books takes time – like carefully inserting them in the right order. Writes can be slower than with an LSM tree.\n\n\n\nSo before jumping on conclusion let's implement and see one by one.\n\n## LSM Tree Structure:\n\nMultiple levels of in-memory (MemTable) and disk-based (SSTables) components.\n\nNew writes go to MemTable, optimized for fast writes.\n\nMemTable flushes to disk as SSTables when full.\n\nSSTables are immutable and sequentially written for fast reads.\n\nPeriodic compaction merges sorted SSTables, removing duplicates and optimizing for reads.\n\n```\nclass LSMTree {\n    private MemTable memTable;\n    private List<SSTable> levels; // Multiple levels of SSTables\n\n    public void Insert(Key key, Value value) {\n        memTable.Insert(key, value);\n        if (memTable.IsFull()) {\n            FlushMemTable();\n        }\n    }\n\n    private void FlushMemTable() {\n        SSTable ssTable = memTable.CreateSSTable();\n        levels.Add(ssTable);\n        memTable = new MemTable(); // Create a new empty MemTable\n        if (levels.Count > MaxLevels) {\n            CompactLevels();\n        }\n    }\n\n    private void CompactLevels() {\n        // Merge and sort SSTables from lower levels to higher levels, removing duplicates\n        // This process optimizes read performance and controls disk usage\n    }\n\n    public Value Get(Key key) {\n        Value value = memTable.Get(key);\n        if (value == null) {\n            // Search through SSTables in levels, starting from the newest\n            // Use a merge-sort strategy to combine results efficiently\n        }\n        return value;\n    }\n}\n\n```\n\nKey Considerations for Implementation:\n\nMemTable: Implement using a hash table or similar structure for fast writes.\n\nSSTables: Use B-trees or other efficient on-disk data structures for reads.\n\nCompaction: Choose a suitable compaction strategy (e.g., size-tiered, leveled) based on workload characteristics.\n\nMerge-Sort: Implement efficient merge-sort algorithms for key-value pairs during compaction and reads.\n\n\n\n### Key Concepts for Implementing B + tree.\n\n\nA balanced tree with variable-sized nodes.\n\nInternal nodes store keys and pointers to child nodes.\n\nLeaf nodes store keys and associated values.\n\nAll leaf nodes are at the same level, forming a linked list.\n\nKey Considerations for Implementation:\n\nMemTable: Implement using a hash table or similar structure for fast writes.\n\nSSTables: Use B-trees or other efficient on-disk data structures for reads.\n\nCompaction: Choose a suitable compaction strategy (e.g., size-tiered, leveled) based on workload characteristics.\n\nMerge-Sort: Implement efficient merge-sort algorithms for key-value pairs during compaction and reads.\n\n\n\nKey Operations:\n\nInsert, Search, Delete, Range queries, Maintaining balance through splitting and merging nodes.\n\n```\nclass BPlusTree {\n    private Node root;\n    private int order; // Maximum number of keys per node\n\n    // Node structure (can be further refined for internal and leaf nodes)\n    private class Node {\n        public List<Key> Keys { get; set; }\n        public List<Node> Children { get; set; } // Only for internal nodes\n        public List<Value> Values { get; set; } // Only for leaf nodes\n    }\n\n    // Insert a key-value pair\n    public void Insert(Key key, Value value) {\n        Node leaf = FindLeafNode(key);\n        InsertIntoLeaf(leaf, key, value);\n        if (leaf.Keys.Count > order - 1) { // Split leaf if full\n            SplitLeaf(leaf);\n        }\n    }\n\n    // Search for a key\n    public Value Search(Key key) {\n        Node leaf = FindLeafNode(key);\n        int index = leaf.Keys.BinarySearch(key);\n        if (index >= 0) {\n            return leaf.Values[index];\n        } else {\n            return null; // Key not found\n        }\n    }\n\n    // Helper functions for node splitting, merging, etc.\n    // ...\n}\n\n```\n\n### Key Implementation Considerations:\n\n**Node Management**: Implement internal and leaf nodes with appropriate properties.\n\n**Searching**: Use efficient algorithms like binary search within nodes.\n\n**Insertion and Deletion**: Handle node splitting and merging to maintain balance.\n\n**Range Queries**: Leverage the linked leaf nodes for efficient traversal.\n\n\n\nso now for me it's a draw, but with different prize categories. Here's when each shines:\n\n### LSM Tree Wins:\n\nWrite-heavy workloads: Think social media feeds or banking transactions. You need to store data fast, even if reading it sometimes requires a moment of patience.\n\nScalability: As your data grows, LSM trees adapt gracefully. New \"notepads\" can be added seamlessly.\n\nDurability: Even if the system crashes, data in the in-memory structures and partially-compacted files is often recoverable.\n\n### B+ Tree Wins:\n\nRead-heavy workloads: Need lightning-fast searches? B+ trees are your allies. No merge delays, just straight to the data.\n\nPredictable performance: Writes might be slower, but they're consistent. No surprises, just reliable performance.\n\nEfficiency: Once compacted, B+ trees offer space-efficient data storage. No duplicate scribbles in your library.\n\nUltimately, the choice is yours. Consider your application's priorities. Need nimble writes over instant reads? The LSM tree beckons. Crave quick searches and predictable performance? The B+ tree awaits. Choose your champion wisely, and your database will be a champion in its own right.\n\nRemember, there's no one-size-fits-all solution. So, explore, experiment, and let the data structure duel guide you to the perfect fit for your database needs!\n\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"lsm-tree-structure","text":"LSM Tree Structure:"},{"depth":3,"slug":"key-concepts-for-implementing-b--tree","text":"Key Concepts for Implementing B + tree."},{"depth":3,"slug":"key-implementation-considerations","text":"Key Implementation Considerations:"},{"depth":3,"slug":"lsm-tree-wins","text":"LSM Tree Wins:"},{"depth":3,"slug":"b-tree-wins","text":"B+ Tree Wins:"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
