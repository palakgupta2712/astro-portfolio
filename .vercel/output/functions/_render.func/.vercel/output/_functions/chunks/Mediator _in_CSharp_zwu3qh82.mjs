import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_2Dcw_akG.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<p>For a while think about a bustling marketplace, brimming with vendors hawking their wares. To get what you need, you have to weave through the throng, shouting your requests to each booth. It’s loud, confusing, and frankly, not very efficient. Now picture this: a central plaza with a town crier. You simply tell the crier what you’re looking for, and they relay it to everyone. Order emerges from chaos, and you leave with your prize much faster.</p>\n<p>That’s the magic of the Mediator pattern in software development. This is a behavioural design pattern that lowers dependency between programme components by having them communicate indirectly via a particular mediator object. Individual components can be easily modified, extended, and reused thanks to the Mediator, which eliminates their reliance on dozens of other classes.</p>\n<p>Just like the town crier, the mediator acts as a central hub for communication between objects. No longer do they need to shout directly at each other, creating a tangle of dependencies and complexity. Instead, they whisper their needs to the mediator, who then sorts it all out and ensures everyone gets what they need.</p>\n<p>This makes code cleaner, more maintainable, and less prone to errors. If the rules of communication change, you only need to adjust the mediator, not every single connected object. It’s like changing the town crier’s script instead of rewriting all the vendor dialogues.</p>\n<p>Here’s how the mediator works in a common example: a chat application. Imagine several users online, typing away furiously. Without a mediator, user A would need to know about user B, C, and everyone else to send messages. This tangled web of dependencies grows quickly as more users join, making the code brittle and hard to manage.</p>\n<p>Enter the chatroom mediator! Users talk to the mediator, who figures out who needs to hear what. If Alice sends a message, the mediator broadcasts it to everyone else in the room. No need for Alice to know or care about how many people are listening. The mediator handles the delivery, like a digital postman.</p>\n<h3 id=\"uml-design\">UML DESIGN</h3>\n<p><img src=\"https://github.com/iamitprakash/astro-portfolio/assets/34869115/ce913b09-3ea4-4334-83db-b99f549867ef\" alt=\"image\"></p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>interface IChatRoomMediator</span></span>\n<span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>  void Send(string message, Participant participant);</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>class ChatRoomMediator : IChatRoomMediator</span></span>\n<span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>  private List&#x3C;Participant> participants = new List&#x3C;Participant>();</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public void AddParticipant(Participant participant)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>      participants.Add(participant);</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public void Send(string message, Participant sender)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>      foreach (Participant participant in participants)</span></span>\n<span class=\"line\"><span>      {</span></span>\n<span class=\"line\"><span>          if (participant != sender)</span></span>\n<span class=\"line\"><span>          {</span></span>\n<span class=\"line\"><span>              participant.Receive(message);</span></span>\n<span class=\"line\"><span>          }</span></span>\n<span class=\"line\"><span>      }</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>abstract class Participant</span></span>\n<span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>  protected IChatRoomMediator mediator;</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public Participant(IChatRoomMediator mediator)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>      this.mediator = mediator;</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public abstract void Send(string message);</span></span>\n<span class=\"line\"><span>  public abstract void Receive(string message);</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>class ConcreteParticipantA : Participant</span></span>\n<span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>  public ConcreteParticipantA(IChatRoomMediator mediator) : base(mediator)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public override void Send(string message)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>      Console.WriteLine($\"{this.GetType().Name}: Sending message: {message}\");</span></span>\n<span class=\"line\"><span>      mediator.Send(message, this);</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>  public override void Receive(string message)</span></span>\n<span class=\"line\"><span>  {</span></span>\n<span class=\"line\"><span>      Console.WriteLine($\"{this.GetType().Name}: Received message: {message}\");</span></span>\n<span class=\"line\"><span>  }</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>// Similar implementation for ConcreteParticipantB</span></span></code></pre>\n<h2 id=\"real-world-example-chat-room-use-case\">Real World example (chat room use case)</h2>\n<p>Let’s implement a Mediator pattern facilitating loosely coupled communication between different Participants registering with a Chatroom. The Chatroom is the central hub through which all communication takes place. At this point only one-to-one communication is implemented in the Chatroom, but would be trivial to change to one-to-many.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>using System;</span></span>\n<span class=\"line\"><span>using System.Collections.Generic;</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>namespace Mediator.RealWorld</span></span>\n<span class=\"line\"><span>{</span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// Mediator Design Pattern</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public class Program</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        public static void Main(string[] args)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            // Create chatroom</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Chatroom chatroom = new Chatroom();</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            // Create participants and register them</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Participant George = new Beatle(\"George\");</span></span>\n<span class=\"line\"><span>            Participant Paul = new Beatle(\"Paul\");</span></span>\n<span class=\"line\"><span>            Participant Ringo = new Beatle(\"Ringo\");</span></span>\n<span class=\"line\"><span>            Participant John = new Beatle(\"John\");</span></span>\n<span class=\"line\"><span>            Participant Yoko = new NonBeatle(\"Yoko\");</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            chatroom.Register(George);</span></span>\n<span class=\"line\"><span>            chatroom.Register(Paul);</span></span>\n<span class=\"line\"><span>            chatroom.Register(Ringo);</span></span>\n<span class=\"line\"><span>            chatroom.Register(John);</span></span>\n<span class=\"line\"><span>            chatroom.Register(Yoko);</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            // Chatting participants</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Yoko.Send(\"John\", \"Hi John!\");</span></span>\n<span class=\"line\"><span>            Paul.Send(\"Ringo\", \"All you need is love\");</span></span>\n<span class=\"line\"><span>            Ringo.Send(\"George\", \"My sweet Lord\");</span></span>\n<span class=\"line\"><span>            Paul.Send(\"John\", \"Can't buy me love\");</span></span>\n<span class=\"line\"><span>            John.Send(\"Yoko\", \"My sweet love\");</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            // Wait for user</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            Console.ReadKey();</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// The 'Mediator' abstract class</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public abstract class AbstractChatroom</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        public abstract void Register(Participant participant);</span></span>\n<span class=\"line\"><span>        public abstract void Send(</span></span>\n<span class=\"line\"><span>            string from, string to, string message);</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// The 'ConcreteMediator' class</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public class Chatroom : AbstractChatroom</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        private Dictionary&#x3C;string, Participant> participants = new Dictionary&#x3C;string, Participant>();</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public override void Register(Participant participant)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            if (!participants.ContainsValue(participant))</span></span>\n<span class=\"line\"><span>            {</span></span>\n<span class=\"line\"><span>                participants[participant.Name] = participant;</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            participant.Chatroom = this;</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public override void Send(string from, string to, string message)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            Participant participant = participants[to];</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>            if (participant != null)</span></span>\n<span class=\"line\"><span>            {</span></span>\n<span class=\"line\"><span>                participant.Receive(from, message);</span></span>\n<span class=\"line\"><span>            }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// The 'AbstractColleague' class</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public class Participant</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        Chatroom chatroom;</span></span>\n<span class=\"line\"><span>        string name;</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        // Constructor</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public Participant(string name)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            this.name = name;</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        // Gets participant name</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public string Name</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            get { return name; }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        // Gets chatroom</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public Chatroom Chatroom</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            set { chatroom = value; }</span></span>\n<span class=\"line\"><span>            get { return chatroom; }</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        // Sends message to given participant</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public void Send(string to, string message)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            chatroom.Send(name, to, message);</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        // Receives message from given participant</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public virtual void Receive(</span></span>\n<span class=\"line\"><span>            string from, string message)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            Console.WriteLine(\"{0} to {1}: '{2}'\",</span></span>\n<span class=\"line\"><span>                from, Name, message);</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// A 'ConcreteColleague' class</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public class Beatle : Participant</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        // Constructor</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public Beatle(string name)</span></span>\n<span class=\"line\"><span>            : base(name)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public override void Receive(string from, string message)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            Console.Write(\"To a Beatle: \");</span></span>\n<span class=\"line\"><span>            base.Receive(from, message);</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    /// &#x3C;summary></span></span>\n<span class=\"line\"><span>    /// A 'ConcreteColleague' class</span></span>\n<span class=\"line\"><span>    /// &#x3C;/summary></span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>    public class NonBeatle : Participant</span></span>\n<span class=\"line\"><span>    {</span></span>\n<span class=\"line\"><span>        // Constructor</span></span>\n<span class=\"line\"><span>        public NonBeatle(string name)</span></span>\n<span class=\"line\"><span>            : base(name)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>        public override void Receive(string from, string message)</span></span>\n<span class=\"line\"><span>        {</span></span>\n<span class=\"line\"><span>            Console.Write(\"To a non-Beatle: \");</span></span>\n<span class=\"line\"><span>            base.Receive(from, message);</span></span>\n<span class=\"line\"><span>        }</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>}</span></span></code></pre>\n<h2 id=\"key-takeaway\">Key takeaway:</h2>\n<p>Benefits:</p>\n<ol>\n<li><strong>Reduced coupling</strong>: Objects don’t need to know about each other’s internal details.</li>\n<li><strong>Enhanced maintainability</strong>: Changes to interactions can be made in the mediator without affecting colleagues.</li>\n<li><strong>Centralized control</strong>: Logic for complex interactions is consolidated in the mediator.</li>\n<li>**Reusability: Colleagues can be reused independently in different contexts.</li>\n</ol>\n<h2 id=\"common-use-cases\">Common Use Cases:</h2>\n<ol>\n<li>GUI components (buttons, menus, windows)</li>\n<li>Chat applications</li>\n<li>Game event systems</li>\n<li>Air traffic control systems</li>\n<li>Multi-threaded applications</li>\n</ol>\n<h2 id=\"considerations\">Considerations:</h2>\n<ol>\n<li>Mediator can become a central point of complexity.</li>\n<li>Overuse can lead to a God object anti-pattern.</li>\n<li>Use judiciously when benefits outweigh potential drawbacks.</li>\n</ol>";

				const frontmatter = {"title":"Mediator in C#","pubDate":"2024-01-13","description":"Mediator in C#","author":"Amit Prakash","image":{"url":"https://media.licdn.com/dms/image/D5612AQGJM8WzCr7Fdg/article-cover_image-shrink_720_1280/0/1705136015310?e=1710979200&v=beta&t=ncMvOLNk0LjSh4sz-VPxBJwwzguQu_5v6DkmC3yqM6U","alt":"The full Astro logo."},"tags":["astro","blogging","learning in public"]};
				const file = "/Users/yashraj/Documents/pr/tejas-portfolio/src/content/posts/Mediator _in_CSharp.md";
				const url = undefined;
				function rawContent() {
					return "\nFor a while think about a bustling marketplace, brimming with vendors hawking their wares. To get what you need, you have to weave through the throng, shouting your requests to each booth. It's loud, confusing, and frankly, not very efficient. Now picture this: a central plaza with a town crier. You simply tell the crier what you're looking for, and they relay it to everyone. Order emerges from chaos, and you leave with your prize much faster.\n\nThat's the magic of the Mediator pattern in software development. This is a behavioural design pattern that lowers dependency between programme components by having them communicate indirectly via a particular mediator object. Individual components can be easily modified, extended, and reused thanks to the Mediator, which eliminates their reliance on dozens of other classes.\n\nJust like the town crier, the mediator acts as a central hub for communication between objects. No longer do they need to shout directly at each other, creating a tangle of dependencies and complexity. Instead, they whisper their needs to the mediator, who then sorts it all out and ensures everyone gets what they need.\n\nThis makes code cleaner, more maintainable, and less prone to errors. If the rules of communication change, you only need to adjust the mediator, not every single connected object. It's like changing the town crier's script instead of rewriting all the vendor dialogues.\n\nHere's how the mediator works in a common example: a chat application. Imagine several users online, typing away furiously. Without a mediator, user A would need to know about user B, C, and everyone else to send messages. This tangled web of dependencies grows quickly as more users join, making the code brittle and hard to manage.\n\nEnter the chatroom mediator! Users talk to the mediator, who figures out who needs to hear what. If Alice sends a message, the mediator broadcasts it to everyone else in the room. No need for Alice to know or care about how many people are listening. The mediator handles the delivery, like a digital postman.\n\n### UML DESIGN\n\n![image](https://github.com/iamitprakash/astro-portfolio/assets/34869115/ce913b09-3ea4-4334-83db-b99f549867ef)\n\n```\ninterface IChatRoomMediator\n{\n  void Send(string message, Participant participant);\n}\n\nclass ChatRoomMediator : IChatRoomMediator\n{\n  private List<Participant> participants = new List<Participant>();\n\n  public void AddParticipant(Participant participant)\n  {\n      participants.Add(participant);\n  }\n\n  public void Send(string message, Participant sender)\n  {\n      foreach (Participant participant in participants)\n      {\n          if (participant != sender)\n          {\n              participant.Receive(message);\n          }\n      }\n  }\n}\n\nabstract class Participant\n{\n  protected IChatRoomMediator mediator;\n\n  public Participant(IChatRoomMediator mediator)\n  {\n      this.mediator = mediator;\n  }\n\n  public abstract void Send(string message);\n  public abstract void Receive(string message);\n}\n\nclass ConcreteParticipantA : Participant\n{\n  public ConcreteParticipantA(IChatRoomMediator mediator) : base(mediator)\n  {\n  }\n\n  public override void Send(string message)\n  {\n      Console.WriteLine($\"{this.GetType().Name}: Sending message: {message}\");\n      mediator.Send(message, this);\n  }\n\n  public override void Receive(string message)\n  {\n      Console.WriteLine($\"{this.GetType().Name}: Received message: {message}\");\n  }\n}\n\n// Similar implementation for ConcreteParticipantB\n```\n\n## Real World example (chat room use case)\n\nLet's implement a Mediator pattern facilitating loosely coupled communication between different Participants registering with a Chatroom. The Chatroom is the central hub through which all communication takes place. At this point only one-to-one communication is implemented in the Chatroom, but would be trivial to change to one-to-many.\n\n```\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mediator.RealWorld\n{\n    /// <summary>\n    /// Mediator Design Pattern\n    /// </summary>\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            // Create chatroom\n\n            Chatroom chatroom = new Chatroom();\n\n            // Create participants and register them\n\n            Participant George = new Beatle(\"George\");\n            Participant Paul = new Beatle(\"Paul\");\n            Participant Ringo = new Beatle(\"Ringo\");\n            Participant John = new Beatle(\"John\");\n            Participant Yoko = new NonBeatle(\"Yoko\");\n\n            chatroom.Register(George);\n            chatroom.Register(Paul);\n            chatroom.Register(Ringo);\n            chatroom.Register(John);\n            chatroom.Register(Yoko);\n\n            // Chatting participants\n\n            Yoko.Send(\"John\", \"Hi John!\");\n            Paul.Send(\"Ringo\", \"All you need is love\");\n            Ringo.Send(\"George\", \"My sweet Lord\");\n            Paul.Send(\"John\", \"Can't buy me love\");\n            John.Send(\"Yoko\", \"My sweet love\");\n\n            // Wait for user\n\n            Console.ReadKey();\n        }\n    }\n\n    /// <summary>\n    /// The 'Mediator' abstract class\n    /// </summary>\n\n    public abstract class AbstractChatroom\n    {\n        public abstract void Register(Participant participant);\n        public abstract void Send(\n            string from, string to, string message);\n    }\n\n    /// <summary>\n    /// The 'ConcreteMediator' class\n    /// </summary>\n\n    public class Chatroom : AbstractChatroom\n    {\n        private Dictionary<string, Participant> participants = new Dictionary<string, Participant>();\n\n        public override void Register(Participant participant)\n        {\n            if (!participants.ContainsValue(participant))\n            {\n                participants[participant.Name] = participant;\n            }\n\n            participant.Chatroom = this;\n        }\n\n        public override void Send(string from, string to, string message)\n        {\n            Participant participant = participants[to];\n\n            if (participant != null)\n            {\n                participant.Receive(from, message);\n            }\n        }\n    }\n\n    /// <summary>\n    /// The 'AbstractColleague' class\n    /// </summary>\n\n    public class Participant\n    {\n        Chatroom chatroom;\n        string name;\n\n        // Constructor\n\n        public Participant(string name)\n        {\n            this.name = name;\n        }\n\n        // Gets participant name\n\n        public string Name\n        {\n            get { return name; }\n        }\n\n        // Gets chatroom\n\n        public Chatroom Chatroom\n        {\n            set { chatroom = value; }\n            get { return chatroom; }\n        }\n\n        // Sends message to given participant\n\n        public void Send(string to, string message)\n        {\n            chatroom.Send(name, to, message);\n        }\n\n        // Receives message from given participant\n\n        public virtual void Receive(\n            string from, string message)\n        {\n            Console.WriteLine(\"{0} to {1}: '{2}'\",\n                from, Name, message);\n        }\n    }\n\n    /// <summary>\n    /// A 'ConcreteColleague' class\n    /// </summary>\n\n    public class Beatle : Participant\n    {\n        // Constructor\n\n        public Beatle(string name)\n            : base(name)\n        {\n        }\n\n        public override void Receive(string from, string message)\n        {\n            Console.Write(\"To a Beatle: \");\n            base.Receive(from, message);\n        }\n    }\n\n    /// <summary>\n    /// A 'ConcreteColleague' class\n    /// </summary>\n\n    public class NonBeatle : Participant\n    {\n        // Constructor\n        public NonBeatle(string name)\n            : base(name)\n        {\n        }\n\n        public override void Receive(string from, string message)\n        {\n            Console.Write(\"To a non-Beatle: \");\n            base.Receive(from, message);\n        }\n    }\n}\n```\n\n## Key takeaway:\n\nBenefits:\n\n1. **Reduced coupling**: Objects don't need to know about each other's internal details.\n2. **Enhanced maintainability**: Changes to interactions can be made in the mediator without affecting colleagues.\n3. **Centralized control**: Logic for complex interactions is consolidated in the mediator.\n4. \\*\\*Reusability: Colleagues can be reused independently in different contexts.\n\n## Common Use Cases:\n\n1. GUI components (buttons, menus, windows)\n2. Chat applications\n3. Game event systems\n4. Air traffic control systems\n5. Multi-threaded applications\n\n## Considerations:\n\n1. Mediator can become a central point of complexity.\n2. Overuse can lead to a God object anti-pattern.\n3. Use judiciously when benefits outweigh potential drawbacks.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":3,"slug":"uml-design","text":"UML DESIGN"},{"depth":2,"slug":"real-world-example-chat-room-use-case","text":"Real World example (chat room use case)"},{"depth":2,"slug":"key-takeaway","text":"Key takeaway:"},{"depth":2,"slug":"common-use-cases","text":"Common Use Cases:"},{"depth":2,"slug":"considerations","text":"Considerations:"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
